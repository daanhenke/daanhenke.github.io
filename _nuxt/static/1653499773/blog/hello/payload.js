__NUXT_JSONP__("/blog/hello", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A){return {data:[{}],fetch:{"data-v-60469dc0:0":{navItems:[{name:"Home",path:"\u002F",primary:p},{name:"Blog",path:q,primary:p},{name:r,path:s,primary:false}]},"data-v-58e2c646:0":{post:{slug:"hello",description:"In this series of blog posts I'll try to explain the process of modifying existing proprietary software without cooperation of the original developer.",title:"Modifying software without source code - Part 1",toc:[{id:t,depth:h,text:u},{id:v,depth:h,text:w},{id:x,depth:h,text:y}],body:{type:"root",children:[{type:b,tag:d,props:{},children:[{type:a,value:"In this series of blog posts I'll try to explain the process of modifying existing proprietary software without cooperation of the original developer.\nYou can do a bunch of things with this like making tweaks to games, Windows kernel & userland components and basically whatever software you feel comfortable reverse engineering."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"In the first episode I'd like to explain a way to get our code inside your target program, assuming it's a normal Windows program, and show relevant code."}]},{type:a,value:c},{type:b,tag:i,props:{id:t},children:[{type:b,tag:f,props:{href:"#dynamic-library-injection",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:u}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The simpelest way to get your code into an existing process is through DLL injection, to explain how it works we need to know how dynamic linking works."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Dynamic linking allows code to be split into multiple modules, that can then be loaded in either at load time or whenever they are required. They are often used for plugin systems because they are an incredibly easy way to load code. On Windows, this is done using the "},{type:b,tag:e,props:{},children:[{type:a,value:"LoadLibraryA(LPCSTR  lpLibFileName)"}]},{type:a,value:" function. Sadly this function only allows us to load a dll into our own process, not into an already existing process, so how can we work around this?"}]},{type:a,value:c},{type:b,tag:i,props:{id:v},children:[{type:b,tag:f,props:{href:"#plan-of-attack",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We have two options, either reimplement "},{type:b,tag:e,props:{},children:[{type:a,value:g}]},{type:a,value:" (basically manual mapping), which isn't that difficult. But it does take quite a bunch of code and goes outside of the scope of this article. Instead what if there was a function that allows us to call other functions in the context of another process?"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Introducing "},{type:b,tag:e,props:{},children:[{type:a,value:"CreateRemoteThread(HANDLE hProcess, ..., LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ...)"}]},{type:a,value:", a function which allows you to spawn a new thread inside an already existing process, setting it's initial address to whatever function pointer you want and even allowing you to pass a single argument via lpParameter, this is perfect for calling "},{type:b,tag:e,props:{},children:[{type:a,value:g}]},{type:a,value:o}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Now there are some more problems we have to solve, first of all we can't just pass a pointer to a string as the argument of "},{type:b,tag:e,props:{},children:[{type:a,value:g}]},{type:a,value:" because that pointer will exist inside our process's memory space, not our target process meaning LoadLibrary would basically be fed a garbage pointer. Instead we need to allocate some memory inside our target process, copy our dll path inside of it and then we can call "},{type:b,tag:e,props:{},children:[{type:a,value:g}]},{type:a,value:" using "},{type:b,tag:e,props:{},children:[{type:a,value:"CreateRemoteThread"}]},{type:a,value:o}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This can be done using "},{type:b,tag:e,props:{},children:[{type:a,value:"VirtualAllocEx"}]},{type:a,value:" & "},{type:b,tag:e,props:{},children:[{type:a,value:"WriteProcessMemory"}]},{type:a,value:o}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This should be enough information to develop a tiny injector. The only thing left to figure out is how to obtain a process handle and that's up to you. You might want to make your injector target it's application based on pid or maybe process executable name."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"If you'd like to see some source code that implements this method of injection check out "},{type:b,tag:f,props:{href:"https:\u002F\u002Fgithub.com\u002Fdaanhenke\u002Fmods\u002Fblob\u002Fmaster\u002Fmodloader\u002Fwin32\u002Finject.cc",rel:["nofollow","noopener","noreferrer"],target:"_blank"},children:[{type:a,value:"modloader's win32 implementation"}]}]},{type:a,value:c},{type:b,tag:i,props:{id:x},children:[{type:b,tag:f,props:{href:"#creating-a-dll-to-inject",ariaHidden:j,tabIndex:k},children:[{type:b,tag:l,props:{className:[m,n]},children:[]}]},{type:a,value:y}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"When LoadLibrary is done loading your DLL file it will execute the dll's main function, usually called "},{type:b,tag:e,props:{},children:[{type:a,value:"DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)"}]},{type:a,value:". This function will get called on load, unload, and whenever a thread get's created or destroyed."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"We can use this as our entrypoint. Try creating a DllMain that calls "},{type:b,tag:e,props:{},children:[{type:a,value:"MessageBox"}]},{type:a,value:" and inject it onto a program, you'll notice the window is part of the target process \u002F program."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"This obviously doesn't get you all the way there, you still aren't able to modify the program in a meaningful way but it is the first step into creating a mod."}]}]},dir:q,path:"\u002Fblog\u002Fhello",extension:".md",createdAt:z,updatedAt:z}},"data-v-483ebe9e:0":{navItems:[{name:r,path:s},{name:"E-Mail",path:"mailto:daanhenkek@gmail.com",type:A},{name:"CV",path:"\u002Fcv.pdf",type:A}]}},mutations:void 0}}("text","element","\n","p","code","a","LoadLibrary",2,"h2","true",-1,"span","icon","icon-link",".",true,"\u002Fblog","GitHub","https:\u002F\u002Fgithub.com\u002Fdaanhenke","dynamic-library-injection","Dynamic library injection","plan-of-attack","Plan of attack?","creating-a-dll-to-inject","Creating a DLL to inject","2022-05-25T17:28:22.649Z","external")));